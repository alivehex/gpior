FUNC void setup_pc (void) {
	PC = 0xC0000000;
}

FUNC void write_regbit(unsigned long addr, unsigned long mask, int to_set) {
 	unsigned long cache;

	cache = _RDWORD(addr);
	if(to_set) {
		cache |= mask;
	} else {
	 	cache &= ~mask;
	}
	_WDWORD(addr, cache);
}

FUNC void program_pll1div(unsigned long reg, unsigned long div) {
	unsigned long PLL1_STAT; 
	unsigned long PLL1_CMD;
	unsigned long cache;

	PLL1_STAT = 0x01E1A13C;
	PLL1_CMD  = 0x01E1A138;
	
	do {
		cache = _RWORD(PLL1_STAT);
	} while(cache & (1 << 0));

	_WDWORD(reg, div | (1 << 15));
	_WDWORD(PLL1_CMD, 1);

	do {
		cache = _RWORD(PLL1_STAT);
	} while(cache & (1 << 0));

	//while( AM18C_BASE_PLLC1->PLLSTAT & (1 << 0) ); // wait last change
	//*reg = div | (1 << 15);
	//AM18C_BASE_PLLC1->PLLCMD = 1;
	//while( AM18C_BASE_PLLC1->PLLSTAT & (1 << 0) );	
}


FUNC void pllc_init(void) {
	unsigned long PLL0_PLLCTL;
	unsigned long PLL0_PLLM;
	unsigned long PLL0_POSTDIV;

	unsigned long PLL1_PLLCTL;
	unsigned long PLL1_PLLM;
	unsigned long PLL1_POSTDIV;
	unsigned long PLL1_DIV1;
	unsigned long PLL1_DIV2;
	unsigned long PLL1_DIV3;

	PLL0_PLLCTL = 0x01C11100;
	PLL0_PLLM 	= 0x01C11110;
	PLL0_POSTDIV= 0x01C11128;

	PLL1_PLLCTL = 0x01E1A100;
	PLL1_PLLM 	= 0x01E1A110;
	PLL1_POSTDIV= 0x01E1A128;
	PLL1_DIV1 	= 0x01E1A118;
	PLL1_DIV2 	= 0x01E1A11C;
	PLL1_DIV3 	= 0x01E1A120;	

	// init PLLC0
	
	//AM18C_BASE_PLLC0->PLLCTL &= ~(1 << 8); // Internal oscillator
	write_regbit(PLL0_PLLCTL, (1 << 8), 0);	
	
	//AM18C_BASE_PLLC0->PLLCTL &= ~(1 << 5); // allows PLLEN bit to take effect
	write_regbit(PLL0_PLLCTL, (1 << 5), 0);

	//AM18C_BASE_PLLC0->PLLCTL &= ~(1 << 9); // select OSCIN
	write_regbit(PLL0_PLLCTL, (1 << 9), 0);

	//AM18C_BASE_PLLC0->PLLCTL &= ~(1 << 0); // PLLC bypass
	// wait atleast 4 OSCIN cycles
	//dummy_cycles(10);
	write_regbit(PLL0_PLLCTL, (1 << 0), 0);
	_sleep_(1);

	
	//AM18C_BASE_PLLC0->PLLCTL &= ~(1 << 3); // reset PLLC
	write_regbit(PLL0_PLLCTL, (1 << 3), 0);
	
	//AM18C_BASE_PLLC0->PLLCTL &= ~(1 << 1); // out off power down
	write_regbit(PLL0_PLLCTL, (1 << 1), 0);
	
	//AM18C_BASE_PLLC0->PLLM = 24; // 24M * (24 + 1) = 600M
	_WDWORD(PLL0_PLLM, 24);

	//AM18C_BASE_PLLC0->POSTDIV = (1 << 15) | (1 << 0); // POST freq = 600M /2 = 300M
	_WDWORD(PLL0_POSTDIV, (1 << 15) | (1 << 0));

	//AM18C_BASE_PLLC0->PLLCTL |= (1 << 3); // out-off reset
	write_regbit(PLL0_PLLCTL, (1 << 3), 1);
	// wait to PLLC lock, 400 OSC-sysles
	//dummy_cycles(400);
	_sleep_(40);
	// AM18C_BASE_PLLC0->PLLCTL |= (1 << 0); // enable PLLC
	write_regbit(PLL0_PLLCTL, (1 << 0), 1);


	/* init PLL1 */
	// AM18C_BASE_PLLC1->PLLCTL &= ~(1 << 5); // allows PLLEN bit to take effect
	write_regbit(PLL1_PLLCTL, (1 << 5), 0);

	//AM18C_BASE_PLLC1->PLLCTL &= ~(1 << 0); // PLLC bypass
	write_regbit(PLL1_PLLCTL, (1 << 0), 0);

	// wait atleast 4 OSCIN cycles
	//dummy_cycles(10);
	_sleep_(1);
	
	//AM18C_BASE_PLLC1->PLLCTL &= ~(1 << 3); // reset PLLC
	write_regbit(PLL1_PLLCTL, (1 << 3), 0);
	
	//AM18C_BASE_PLLC1->PLLCTL &= ~(1 << 1); // out off power down
	write_regbit(PLL1_PLLCTL, (1 << 1), 0);
	
	//AM18C_BASE_PLLC1->PLLM = 24; // 24M * (24 + 1) = 600M
	_WDWORD(PLL1_PLLM, 24);

	//AM18C_BASE_PLLC1->POSTDIV = (1 << 15) | (1 << 0); // POST freq = 600M /2 = 300M
	_WDWORD(PLL1_POSTDIV, (1 << 15) | (1 << 0));

	// change the DIVn for SYSCLKn
	program_pll1div(PLL1_DIV1, 0);
	program_pll1div(PLL1_DIV2, 1);
	program_pll1div(PLL1_DIV3, 2);
	
	//AM18C_BASE_PLLC1->PLLCTL |= (1 << 3); // out-off reset
	write_regbit(PLL1_PLLCTL, (1 << 3), 1);
	// wait to PLLC lock, 400 OSC-sysles
	//dummy_cycles(400);
	_sleep_(40);
	//AM18C_BASE_PLLC1->PLLCTL |= (1 << 0); // enable PLLC
	write_regbit(PLL1_PLLCTL, (1 << 0), 1);
}

FUNC void system_init(void) {
	unsigned long SYSCFG_KICK0;
	unsigned long SYSCFG_KICK1;
	unsigned long SYSCFG_CFGCHIP0;
	unsigned long SYSCFG_CFGCHIP3;

	SYSCFG_KICK0 = 0x01C14038;
	SYSCFG_KICK1 = 0x01C1403C;
	SYSCFG_CFGCHIP0 = 0x01C1417C;
	SYSCFG_CFGCHIP3 = 0x01C14188;

	// unlock the syscfg register
	//AM18C_BASE_SYSCFG0->KICK0R = 0x83E70B13;
	//AM18C_BASE_SYSCFG0->KICK1R = 0x95A4F1E0;
	_WDWORD(SYSCFG_KICK0, 0x83E70B13);
	_WDWORD(SYSCFG_KICK1, 0x95A4F1E0); 
	
	//AM18C_BASE_SYSCFG0->CFGCHIP[0] |= (1 << 4); // lock PLLC0
	//AM18C_BASE_SYSCFG0->CFGCHIP[3] |= (1 << 5); // lock PLLC1
	//write_regbit(SYSCFG_CFGCHIP0, (1 << 4), 1);
	//write_regbit(SYSCFG_CFGCHIP3, (1 << 5), 1);
}

FUNC void psc_ddrc_enable(void) {
	unsigned long PCS_PTSTAT;
	unsigned long PCS_MDCTL6;
	unsigned long PCS_PTCMD;
	unsigned long cache;
	
	// DDRC at PCS1
	PCS_PTSTAT = 0x01E27128;
	PCS_MDCTL6 = 0x01E27A18;
	PCS_PTCMD  = 0x01E27120;
	
	do {
		cache = _RDWORD(PCS_PTSTAT);
	} while(cache & (1 << 0));
	_WDWORD(PCS_MDCTL6, 3 | (1 << 8));
	_WDWORD(PCS_PTCMD, (1 << 0));
	do {
		cache = _RDWORD(PCS_PTSTAT);
	} while(cache & (1 << 0)); 

	//while(pcs->PTSTAT & (1 << 0));
	//pcs->MDCTL[id] = mask | (1 << 8);
	//pcs->PTCMD = (1 << 0);
	//while(pcs->PTSTAT & (1 << 0));
}

FUNC void psc_ddrc_reset(void) {
	unsigned long PCS_MDCTL6;
	
	// DDRC at PCS1
	PCS_MDCTL6 = 0x01E27A18;

 	//pcs->MDCTL[id] &= ~(1 << 8);
	write_regbit(PCS_MDCTL6, (1 << 8), 0);

	//__asm {
	//	nop;nop;nop;
	//};
	_sleep_(1);

	//pcs->MDCTL[id] |= (1 << 8);
	write_regbit(PCS_MDCTL6, (1 << 8), 1);
}

FUNC void vtp_clkrz_pulse(void) {
	unsigned long VTPIO_CTL;
	
	VTPIO_CTL = 0x01E2C000;
	write_regbit(VTPIO_CTL, (1 << 13), 1);
	_sleep_(1);
	write_regbit(VTPIO_CTL, (1 << 13), 0);
	_sleep_(1);
	write_regbit(VTPIO_CTL, (1 << 13), 1);	

	
	//AM18C_BASE_SYSCFG1->VTPIO_CTL |= (1 << 13);
	//__asm {
	//	nop;nop;nop;nop;
	//};
	//AM18C_BASE_SYSCFG1->VTPIO_CTL &= ~(1 << 13);
	//__asm {
	//	nop;nop;nop;nop;
	//};
	//AM18C_BASE_SYSCFG1->VTPIO_CTL |= (1 << 13);
}

FUNC void ddrc_vtpio_calibration(void) {
	unsigned long VTPIO_CTL;
	unsigned long cache;
	unsigned long timeout;	

	VTPIO_CTL = 0x01E2C000;
	write_regbit(VTPIO_CTL, (1 << 6), 0);
	write_regbit(VTPIO_CTL, (1 << 7), 0);
	vtp_clkrz_pulse();
	
	timeout = 100;
	do {
		cache = _RDWORD(VTPIO_CTL);
		_sleep_(1);
	} while((!(cache & (1 << 15))) && (-- timeout));
	if(timeout == 0) {
	 	printf("ddrc VTPIO_CTL timeout!\n");
	}
	
	write_regbit(VTPIO_CTL, (1 << 7), 1);
	write_regbit(VTPIO_CTL, (1 << 6), 1);
	write_regbit(VTPIO_CTL, (1 << 14), 1);
			
	//AM18C_BASE_SYSCFG1->VTPIO_CTL &= ~(1 << 6); // power-on
	//AM18C_BASE_SYSCFG1->VTPIO_CTL &= ~(1 << 7); // unlock
	//vtp_clkrz_pulse();
	//while(!(AM18C_BASE_SYSCFG1->VTPIO_CTL & (1 << 15)));
	//AM18C_BASE_SYSCFG1->VTPIO_CTL |= (1 << 7); // lock
	//AM18C_BASE_SYSCFG1->VTPIO_CTL |= (1 << 6); // power-down
	//AM18C_BASE_SYSCFG1->VTPIO_CTL |= (1 << 14); // save power	
}

FUNC void ddrc_init(void) {
	unsigned long DDRC_BASE;
	unsigned long DRPYC1R;
	unsigned long DDR_SLEW;
	unsigned long DDR_SDCR;
	unsigned long SDTIMR1;
	unsigned long SDTIMR2;
	unsigned long SDRCR;
	unsigned long PBBPR;

	unsigned long DDRC_DEF_SDCR;
	unsigned long DDRC_DEF_SDTIMR1;
	unsigned long DDRC_DEF_SDTIMR2;
	unsigned long DDRC_DEF_SDRCR;

	DDRC_DEF_SDCR = (1 << 20) | (1 << 17) | (1 << 16) | (1 << 15) | (1 << 14) |	(3 << 4)  | (2 << 0);
	DDRC_DEF_SDTIMR1 = (19 << 25) | (2 << 22) | (2 << 19) | (2 << 16) | (5 << 11)  | (8 <<  6) | (1 <<  3) | (1 << 0);
	DDRC_DEF_SDTIMR2 = (8 << 27) | (2 << 25) | (18 << 16) | (199 << 8) | (1 <<  5) | (2 << 0);
	DDRC_DEF_SDRCR = (1 << 31) | (1 << 30) | 0x400;

	DDRC_BASE = 0xB0000000;
	DDR_SLEW = 0x01E2C004;
	DRPYC1R	 = (DDRC_BASE + 0x000000E4);
	DDR_SDCR = (DDRC_BASE + 0x00000008);
	SDTIMR1	 = (DDRC_BASE + 0x00000010);
	SDTIMR2	 = (DDRC_BASE + 0x00000014);
	SDRCR	 = (DDRC_BASE + 0x0000000C);
	PBBPR	 = (DDRC_BASE + 0x00000020);

	
	printf("DDRC_BASE = 0x%x\n", DDRC_BASE);
	printf("DDR_SDCR = 0x%x\n", DDR_SDCR);

	//psc_module_config(AM18C_ID_DDR2, MODULE_STATE_ENABLE);
	psc_ddrc_enable();	
	//ddrc_vtpio_calibration();
	
	// RL = 2
	//AM18C_BASE_DDRC->DRPYC1R = (1 << 6) | 4;
	_WDWORD(DRPYC1R, ((1 << 6) | 4));
	
	// DDR2 mode
	//AM18C_BASE_SYSCFG1->DDR_SLEW &= ~((1 << 5) | (1 << 4));
	write_regbit(DDR_SLEW, ((1 << 5) | (1 << 4)), 0);

	//AM18C_BASE_DDRC->SDCR |= (1 << 23);
	write_regbit(DDR_SDCR, (1 << 23), 1);
	
	//AM18C_BASE_DDRC->SDCR = DDRC_DEF_SDCR;
	_WDWORD(DDR_SDCR, DDRC_DEF_SDCR); 
		
	//AM18C_BASE_DDRC->SDCR |= (3 << 9);
	write_regbit(DDR_SDCR, (3 << 9), 1);
	
	//AM18C_BASE_DDRC->SDTIMR1 = DDRC_DEF_SDTIMR1; 
	_WDWORD(SDTIMR1, DDRC_DEF_SDTIMR1);
	
	//AM18C_BASE_DDRC->SDTIMR2 = DDRC_DEF_SDTIMR2;
	_WDWORD(SDTIMR2, DDRC_DEF_SDTIMR2);
	
	// lock the register
	//AM18C_BASE_DDRC->SDCR &= ~(1 << 15);
	write_regbit(DDR_SDCR, (1 << 15), 0);

	//AM18C_BASE_DDRC->SDCR &= ~(1 << 23);
	write_regbit(DDR_SDCR, (1 << 23), 0);

	//AM18C_BASE_DDRC->SDRCR = DDRC_DEF_SDRCR;
	_WDWORD(SDRCR, DDRC_DEF_SDRCR);
	
	// PCS reset DDRC
	//psc_module_reset(AM18C_ID_DDR2);
	psc_ddrc_reset();
	
	// PCS re-enable DDRC
	//psc_module_config(AM18C_ID_DDR2, MODULE_STATE_ENABLE);
	psc_ddrc_enable();

	//AM18C_BASE_DDRC->SDRCR &= ~((1 << 31) | (1 << 30));
	write_regbit(SDRCR, ((1 << 31) | (1 << 30)), 0);
	
	//AM18C_BASE_DDRC->PBBPR = 0x20;
	_WDWORD(PBBPR, 0x00000020); 
}



pllc_init();
system_init();
ddrc_init();
setup_pc();
LOAD AM1806.axf INCREMENTAL
g, main